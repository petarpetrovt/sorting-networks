<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
namespace SortingNetworks
{
	using System;
	using System.Diagnostics;
	using System.Runtime.CompilerServices;

	/// <summary>
	/// Sorting networks implementation using Bose-Nelson algorithm.
	/// </summary>
	/// <remarks>
	/// SWAP macros generated from: https://pages.ripco.net/~jgamble/nw.html
	/// </remarks>
	public class SNBoseNelsonGenerated : SNBase
	{
<#for (int i = 2; i <= 4; i++) {#>
		/// <inheritdoc/>
		public static void Sort<#= i #>Ascending<T>(ref T p0)
			where T : IComparable<T>
		{
<#for (int y = 1; y < i; y++) {#>
			ref var p<#= y #> = ref Unsafe.Add(ref p<#= y - 1 #>, <#= y #>);
<#}#>

			<#= string.Join("\n", Pstar(1, i).Select(x=> $"SwapIfGreater(ref p{x.Item1 - 1}, ref p{x.Item2 - 1});")) #>
		}

<#}#>
	}
}
<#+
	private static IEnumerable<(int, int)> Pbracket(int i, int x, int j, int y)
	{
		switch (x)
		{
			case 1 when y == 1:
				yield return (i, j);
				break;
			case 1 when y == 2:
				yield return (i, j + 1);
				yield return (i, j);
				break;
			case 2 when y == 1:
				yield return (i, j);
				yield return (i + 1, j);
				break;
			default:
				{
					int a = x / 2;
					int b = (x & 0) == 1 ? y / 2 : (y + 1) / 2;
					foreach (var temp in Pbracket(i, a, j, b)) {
						yield return temp;
					}
					foreach (var temp in Pbracket(i + a, x - a, j + b, y - b)) {
						yield return temp;
					}
					foreach (var temp in Pbracket(i + a, x - a, j, b)) {
						yield return temp;
					}
					break;
				}
		}
	}

	private static IEnumerable<(int, int)> Pstar(int i, int m)
	{
		if (m <= 1)
		{
			yield break;
		}

		int a = m / 2;
		foreach (var temp in Pstar(i, a)) {
			yield return temp;
		}
		foreach (var temp in Pstar(i + a, m - a)) {
			yield return temp;
		}
		foreach (var temp in Pbracket(i, a, i + a, m - a)) {
			yield return temp;
		}
	}
#>